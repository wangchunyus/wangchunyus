(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{293:function(t,a,e){"use strict";e.r(a);var n=e(10),i=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"spring-篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-篇"}},[t._v("#")]),t._v(" Spring 篇")]),t._v(" "),a("h2",{attrs:{id:"ioc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ioc"}},[t._v("#")]),t._v(" IOC")]),t._v(" "),a("h4",{attrs:{id:"general"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#general"}},[t._v("#")]),t._v(" General：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("ioc实现的方式")])]),t._v(" "),a("ul",[a("li",[t._v("纯xml形式（bean信息定义全部配置到xml中管理）")]),t._v(" "),a("li",[t._v("xml+注解形式")]),t._v(" "),a("li",[t._v("纯注解形式")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("IOC容器的启动方式")])]),t._v(" "),a("ul",[a("li",[t._v("带有xml的启动方式\n"),a("ul",[a("li",[t._v("JavaSE："),a("code",[t._v('ApplicationContext app =new ClassPathXmlApplicationContext("beans.xml");')])]),t._v(" "),a("li",[t._v("JavaWeb: "),a("code",[t._v("ContextLoadListener(配置监听器 加载xml)")])])])]),t._v(" "),a("li",[t._v("纯注解形式\n"),a("ul",[a("li",[t._v("JavaSE："),a("code",[t._v("ApplicationContext app =new AnnotationConfigApplicationContext(springConfig.class);")])]),t._v(" "),a("li",[t._v("JavaWeb: "),a("code",[t._v("ContextLoadListener(配置监听器 加载xml)")])])])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Bean作用域")])])]),t._v(" "),a("li",[a("p",[t._v("Singleton  - 单例模式(销毁容器时，对象就被销毁)")])]),t._v(" "),a("li",[a("p",[t._v("Prototype -  原型模式（多例）/ 每次都会生成一个新的bean （spring只负责创建bean，不负责销毁。GC回收）")])]),t._v(" "),a("li",[a("p",[t._v("Request")])]),t._v(" "),a("li",[a("p",[t._v("Seesion")])]),t._v(" "),a("li",[a("p",[t._v("Application")])]),t._v(" "),a("li",[a("p",[t._v("Websocket")])])]),t._v(" "),a("h4",{attrs:{id:"lazy-init-延迟加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lazy-init-延迟加载"}},[t._v("#")]),t._v(" Lazy-Init  延迟加载")]),t._v(" "),a("p",[t._v("ApplicationContext容器中默认是在启动服务器时将所有的 作用域为’singleton‘ 的bean提前初始化。")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("配置延迟加载")])]),t._v(" "),a("ul",[a("li",[t._v("xml方式： 在xml中 "),a("code",[t._v("<bean id ='Test1' class = 'com.edu.....' lazy-init = 'true'>")]),t._v("开启了延迟加载")]),t._v(" "),a("li",[t._v("在纯注解方式： 可以在Test1 的这个实体类上 加上@Lazy 这个注解 表示开启延迟加载")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("应用场景")])]),t._v(" "),a("ul",[a("li",[t._v("开启延迟加载在一定程度上可以提高容器启动和服务器运转性能。")]),t._v(" "),a("li",[t._v("对于不常 使用的Bean设置延迟加载， 可以节省资源消耗。")])])])]),t._v(" "),a("h4",{attrs:{id:"factorybean-和-beanfactory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#factorybean-和-beanfactory"}},[t._v("#")]),t._v(" FactoryBean 和 BeanFactory")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("BeanFactory 接口是容器的顶级接口，定义了容器的一些基础行为，负责产生和管理Bean的工厂，ApplicationContext等属于它的子接口。")])]),t._v(" "),a("li",[a("p",[t._v("FactoryBean 属于Spring中的工厂Bean， 可以生产某一个类型的Bean实例给我们，也就说我们可以自定义Bean的创建过程。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("FactoryBean 是一个接口，提供了三个方法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("T  getObject()  throws Exception;   //返回使用FactoryBean创建的实例")])]),t._v(" "),a("li",[a("p",[t._v("class<?> getObjectType();  //返回创建Bean的类型")])]),t._v(" "),a("li",[a("p",[t._v("default boolean isSingleton() {")]),t._v(" "),a("p",[t._v("return true;")])])]),t._v(" "),a("p",[t._v("} //返回作用域是否单例")])]),t._v(" "),a("li",[a("p",[t._v("FactoryBean 的使用--\x3e  在 myBatis中的 SqlSessionFactoryBean 中使用| spring自身也有 70多个bean使用过。")])])])])])])}),[],!1,null,null,null);a.default=i.exports}}]);