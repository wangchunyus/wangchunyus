(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{293:function(a,n,e){"use strict";e.r(n);var t=e(10),s=Object(t.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"spring-篇"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-篇"}},[a._v("#")]),a._v(" Spring 篇")]),a._v(" "),n("h2",{attrs:{id:"ioc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ioc"}},[a._v("#")]),a._v(" IOC")]),a._v(" "),n("h4",{attrs:{id:"general"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#general"}},[a._v("#")]),a._v(" General：")]),a._v(" "),n("ul",[n("li",[n("p",[n("strong",[a._v("ioc实现的方式")])]),a._v(" "),n("ul",[n("li",[a._v("纯xml形式（bean信息定义全部配置到xml中管理）")]),a._v(" "),n("li",[a._v("xml+注解形式")]),a._v(" "),n("li",[a._v("纯注解形式")])])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("IOC容器的启动方式")])]),a._v(" "),n("ul",[n("li",[a._v("带有xml的启动方式\n"),n("ul",[n("li",[a._v("JavaSE："),n("code",[a._v('ApplicationContext app =new ClassPathXmlApplicationContext("beans.xml");')])]),a._v(" "),n("li",[a._v("JavaWeb: "),n("code",[a._v("ContextLoadListener(配置监听器 加载xml)")])])])]),a._v(" "),n("li",[a._v("纯注解形式\n"),n("ul",[n("li",[a._v("JavaSE："),n("code",[a._v("ApplicationContext app =new AnnotationConfigApplicationContext(springConfig.class);")])]),a._v(" "),n("li",[a._v("JavaWeb: "),n("code",[a._v("ContextLoadListener(配置监听器 加载xml)")])])])])])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("Bean作用域")])])]),a._v(" "),n("li",[n("p",[a._v("Singleton  - 单例模式(销毁容器时，对象就被销毁)")])]),a._v(" "),n("li",[n("p",[a._v("Prototype -  原型模式（多例）/ 每次都会生成一个新的bean （spring只负责创建bean，不负责销毁。GC回收）")])]),a._v(" "),n("li",[n("p",[a._v("Request")])]),a._v(" "),n("li",[n("p",[a._v("Seesion")])]),a._v(" "),n("li",[n("p",[a._v("Application")])]),a._v(" "),n("li",[n("p",[a._v("Websocket")])])]),a._v(" "),n("h4",{attrs:{id:"lazy-init-延迟加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lazy-init-延迟加载"}},[a._v("#")]),a._v(" Lazy-Init  延迟加载")]),a._v(" "),n("p",[a._v("ApplicationContext容器中默认是在启动服务器时将所有的 作用域为’singleton‘ 的bean提前初始化。")]),a._v(" "),n("ul",[n("li",[n("p",[n("strong",[a._v("配置延迟加载")])]),a._v(" "),n("ul",[n("li",[a._v("xml方式： 在xml中 "),n("code",[a._v("<bean id ='Test1' class = 'com.edu.....' lazy-init = 'true'>")]),a._v("开启了延迟加载")]),a._v(" "),n("li",[a._v("在纯注解方式： 可以在Test1 的这个实体类上 加上@Lazy 这个注解 表示开启延迟加载")])])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("应用场景")])]),a._v(" "),n("ul",[n("li",[a._v("开启延迟加载在一定程度上可以提高容器启动和服务器运转性能。")]),a._v(" "),n("li",[a._v("对于不常 使用的Bean设置延迟加载， 可以节省资源消耗。")])])])]),a._v(" "),n("h4",{attrs:{id:"factorybean-和-beanfactory"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#factorybean-和-beanfactory"}},[a._v("#")]),a._v(" FactoryBean 和 BeanFactory")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("BeanFactory 接口是容器的顶级接口，定义了容器的一些基础行为，负责产生和管理Bean的工厂，ApplicationContext等属于它的子接口。")])]),a._v(" "),n("li",[n("p",[a._v("FactoryBean 属于Spring中的工厂Bean， 可以生产某一个类型的Bean实例给我们，也就说我们可以自定义Bean的创建过程。")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("FactoryBean 是一个接口，提供了三个方法")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("T  getObject()  throws Exception;   //返回使用FactoryBean创建的实例")])]),a._v(" "),n("li",[n("p",[a._v("class<?> getObjectType();  //返回创建Bean的类型")])]),a._v(" "),n("li",[n("p",[a._v("default boolean isSingleton() {")]),a._v(" "),n("p",[a._v("return true;")])])]),a._v(" "),n("p",[a._v("} //返回作用域是否单例")])]),a._v(" "),n("li",[n("p",[a._v("FactoryBean 的使用--\x3e  在 myBatis中的 SqlSessionFactoryBean 中使用| spring自身也有 70多个bean使用过。")])])])])]),a._v(" "),n("h4",{attrs:{id:"springbean的后置处理器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#springbean的后置处理器"}},[a._v("#")]),a._v(" SpringBean的后置处理器")]),a._v(" "),n("ul",[n("li",[n("p",[n("strong",[a._v("spring 提供了两种处理bean的扩展接口")])]),a._v(" "),n("ul",[n("li",[n("p",[a._v("BeanPostProcessor "),n("strong",[a._v("（默认是会对整个spring 容器中的所有bean进行处理）")])]),a._v(" "),n("ul",[n("li",[n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("public interface BeanPostProcessor {\n\n// 初始化方法前 执行 ，主要做一些生成bean前的一些前置执行\n   @Nullable\n   default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n      return bean;\n   }\n\n  // 初始化方法后 执行 ，主要做一些生成bean后的一些后置执行\n   @Nullable\n   default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n      return bean;\n   }\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br")])])])])]),a._v(" "),n("li",[n("p",[a._v("BeanFactoryPostProcessor（"),n("strong",[a._v("BeanFactory级别的处理，是针对整个Bean的⼯⼚进⾏处理，典型应")])]),a._v(" "),n("p",[n("strong",[a._v("⽤:PropertyPlaceholderConfifigurer")]),a._v("）")]),a._v(" "),n("ul",[n("li",[a._v("PropertyPlaceholderConfifigurer： 源码中处理 封装xml bean信息的 BeanDefinition 中的一些 properties中的信息  例如：  dataSource 中的一些  数据 ${username} / ${password} 的信息进行 转换后 在封装到 BeanDefinition中")])])])])])]),a._v(" "),n("h4",{attrs:{id:"spring-ioc源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc源码"}},[a._v("#")]),a._v(" Spring-IoC源码")]),a._v(" "),n("ul",[n("li",[a._v("Bean对象创建的关键方法是 AbstractApplicationContext  类中那个的 refaresh() 方法  核心方法")])])])}),[],!1,null,null,null);n.default=s.exports}}]);